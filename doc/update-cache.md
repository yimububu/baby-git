## update-cache.c 的作用与设计

`update-cache.c` 是 Git 初始版本中最关键的命令之一。  
它负责把工作区文件转换成对象并登记到索引（`.dircache/index`），本质上就是今天 `git add` 的早期形态。

如果说 `init-db` 搭好了对象库骨架，那么 `update-cache` 就是第一条真正把“用户文件”推进 Git 数据模型的通道。

## 它具体做了什么

这个程序的核心流程可以概括为三步：

1. 读取现有索引到内存（`active_cache`）。
2. 对每个输入路径，生成/更新对应 `cache_entry`，并把文件内容写成 blob 对象。
3. 把更新后的索引写入 `index.lock`，再原子替换为 `index`。

这三个动作连在一起，构成了“暂存”的完整语义：既有对象落盘，也有快照状态（索引）更新。

## 为什么索引（index）是必要设计

索引不是冗余层，它是 Git 能高质量提交历史的关键机制：

1. 将“编辑”与“提交”解耦  
   工作区可以继续变化，但提交只取索引中的候选快照。这样每次提交都能保持明确意图，而不是把当前目录状态整包打入历史。

2. 支持增量构造提交  
   可以多次执行 `update-cache`，逐步把文件加入索引，最后一次性提交。这个模型直接支持“小步、清晰、可审阅”的历史组织方式。

3. 为提交提供稳定边界  
   索引是可验证、可重建、可对比的中间状态。它让“准备提交什么”这件事在系统层面具备确定性。

## 代码中的 Linux/Unix 设计巧思

这份代码非常短，但技术取舍很典型，体现了 Linux 风格的实用主义。

1. 原子更新而不是原地改写  
   先写 `index.lock`，成功后 `rename` 成正式索引。  
   这是 Unix 文件系统里经典的崩溃一致性手法：要么旧版本，要么新版本，避免半写入状态。

2. 利用 `O_EXCL` 做并发保护  
   `index.lock` 以独占方式创建，防止并发进程同时写索引。  
   不依赖复杂锁服务，只用内核文件语义解决竞争问题，简单且可靠。

3. 有序数组 + 二分查找  
   `active_cache` 始终按路径字典序维护，查找和插入位置用二分确定。  
   数据结构朴素，但在当时代码规模下非常高效，且实现可读性好。

4. 最小化系统调用开销  
   文件内容通过 `mmap` 读取，再直接进入压缩与哈希流程。  
   这减少了用户态拷贝与显式读循环，体现“让内核做擅长的事”的思路。

5. 幂等和容错意识  
   处理文件不存在（`ENOENT`）时，不是简单失败，而是从索引移除该路径。  
   这让“文件删除”与“索引更新”语义自然对齐，降低人工修复成本。

6. 路径规则先于功能  
   通过 `verify_path` 拒绝歧义路径与隐藏路径模式，先把输入约束清楚，再做对象化与索引更新。  
   这种“先保证语义边界”的方式减少了后续逻辑复杂度。

## 在 Git 初始提交中的地位

`update-cache.c` 是初始 Git 提交链路中的中枢：

1. `init-db`：初始化对象库存储结构  
2. `update-cache`：把工作区内容写为 blob，并更新索引  
3. `write-tree`：把索引快照转换成 tree 对象  
4. `commit-tree`：基于 tree 生成 commit 对象

没有 `update-cache`，后续步骤就失去输入来源。  
它让 Git 从“能存对象”变成“能组织快照并进入提交历史”。

## 参考资料

- https://felipec.wordpress.com/2021/08/10/git-staging-area-rename/  
- https://www.reddit.com/r/programming/comments/p26bp4/the_git_staging_area_the_term_literally_everyone/?tl=zh-hans  
- https://git-scm.com/docs/git-add  
- https://git-scm.com/docs/git-commit  
