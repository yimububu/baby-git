
    Git - 愚蠢的内容追踪器

“git”这个词可以代表任何东西，全看你的心情：

 - 一个读起来顺口、且没有被任何常见 UNIX 命令占用过的随机的三个字母组合。它是不是“get”的发音错误，可能有关，也可能无关。
 - 愚蠢的（stupid）、可鄙的（contemptible）、卑劣的（despicable）。简单的。你可以从俚语字典里随便挑一个解释。
 - "Global information tracker"（全局信息追踪器）：当你心情不错，且它确实帮上忙的时候。此时天使歌唱，圣光瞬间充满房间。
 - "Goddamn idiotic truckload of sh*t"（该死的、白痴般的、一卡车的破烂）：当它坏掉时。

这是一个愚蠢（但极快）的目录内容管理器（directory content manager）。它干的事不多，但它确实在
高效地追踪目录内容（track directory contents）。

这里有两个对象抽象：“对象数据库（object database）” 和 “当前目录缓存（current directory cache）”。

    对象数据库 (SHA1_FILE_DIRECTORY)

对象数据库本质上就是一个按内容寻址（content-addressable）的对象集合。所有对象都根据其内容命名，这个命名具体表现为对象本身的 SHA1 哈希值。
对象之间可以通过引用其他对象的 SHA-1 哈希值来互相关联，因此你可以构建出对象的层级结构。

在这个按内容寻址的集合数据库中，有几种类型的对象。它们都经过 zlib 压缩（deflated），并以其类型的标签（tag）和数据大小信息开头。
注意，SHA-1 哈希始终是对压缩后的对象计算的，而不是对原始对象计算的。

特别是，一个对象的一致性总是可以独立于对象的内容或类型进行验证：所有对象都可以通过以下两点进行验证：（a）它的哈希值与文件内容匹配；
（b）对象能成功解压（inflate）成这样一段特定格式的字节流：<不带空格的 ASCII 标签> + <空格> + <ASCII 十进制大小> + <字节 \0> + <二进制对象数据>。

BLOB：一个 “blob” 对象只是一个二进制数据块（binary blob），它不引用任何其他对象。数据本身没有签名，也没有任何其他的数据校验机制，因此虽然对象是一致的（它确实是通过其 sha1 哈希索引的，所以数据本身肯定是正确的）
但它绝对没有其他属性。没有名称关联，没有权限。它纯粹是一块数据（即通常的“文件内容”）。

TREE：下一个层级化的对象类型是 “tree” 对象。一个 tree 对象是由一组权限（permission）/名称（name）/blob引用数据组成的数据列表，并按名称排序。
换句话说，tree 对象由其包含的内容集合唯一决定，因此即便两个 tree 是分别独立生成的，只要内容完全相同，将始终共享同一个确切的对象。

同样，“tree” 对象也只是一个纯粹的数据抽象：它没有历史记录、没有签名，也没有额外的有效性校验，只是其内容仍然由哈希本身保护。
因此，你可以像信任 blob 一样信任 tree 的内容，但你并不知道这些内容是从哪里来的。

关于 tree 的附注：由于一个 “tree” 对象是经过排序的“文件名 + 内容引用”的列表，你可以在比较两个 tree 的差异时，无需真正把它们都解压。只要忽略两者共有的部分，得到的 diff 就是正确的。
换句话说，你可以用 O(n) 的代价判断任意两个 tree 之间的差异，其中 n 是差异的大小，而不是整个 tree 的大小。这使得比较 tree 非常高效。

关于 tree 的附注 2：由于 “blob” 的名称完全且唯一地由其内容决定（即不涉及文件名或权限信息），因此只要 blob 没变，你就能轻松识别出一些简单的操作，例如文件重命名或权限变更。
但如果是文件名变了同时内容也发生变化，那就需要更智能的 diff 实现才能识别出来。

CHANGESET：“changeset” （变更集）对象类型将历史的概念引入了进来。与其他对象不同，它不仅描述某个 tree 的物理状态，还描述我们是如何到达这一状态的，以及到达该状态的原因。

一个 “changeset” 由它生成的 tree 对象、导致该状态的父 “changeset”（零个、一个或多个）以及关于发生了什么的注释（comment）来定义。再次强调，“changeset” 本身并不是绝对可信的：
尽管由于各层级都有高强度的加密签名，其内容是定义明确且“安全”的，但没有理由认为 tree 本身是“正确”的，或者合并信息一定有意义。例如，其父 changeset 节点实际上不必与结果有任何关系。

关于 “changeset” 的说明：不同于真正的 SCM（软件配置管理系统），“changeset” 不包含重命名信息或文件模式变更信息。所有这些都隐含在所涉及的 tree 对象中（结果树，以及父级的结果树），
在这个“白痴般的”文件管理器中描述这些是没有意义的。

TRUST: “信任”的概念实际上超出了“git”的范畴，但有几点值得注意。首先，由于所有内容都使用 SHA-1 进行哈希，你可以相信对象是完整的，并未被外部篡改。因此，一个对象的名称可以唯一标识一个已知状态——只是这个状态不一定是你想要信任的。

此外，由于 changeset 的 SHA-1 签名关联着其对应的 tree 的 SHA-1 签名以及父 changeset 的签名，因此一个指定名称的 changeset 可以唯一确定整套历史及其全部内容。一旦你拥有了一个 changeset 的名称，就无法在之后伪造其中的任何一个步骤。

因此，要在系统中引入真正的可信度，你唯一需要做的就是对一条特殊的记录进行数字签名，该记录包含一个顶层 changeset 的名称。你的数字签名向他人表明你信任该 changeset，而 changeset 历史的不可变性则告诉他人，他们可以信任整个历史记录。

换句话说，你只需发送一封邮件，告诉收件人顶层 changeset 的名称（SHA-1 哈希值），并使用 GPG/PGP 等工具对该邮件进行数字签名，就可以轻松验证整个存档的完整性。

特别是，你还可以建立一个单独的“信任点”或标签（tag）存档，用来记录你（以及其他人）的信任。当然，你可以使用 “git” 本身来存档这些“信任凭证”，但这并不是 “git” 自动为你做的事情。

换种方式说：“git” 本身只保证内容的完整性，而信任必须来自外部。

    当前目录缓存 (".dircache/index")

“当前目录缓存”是一个简单的二进制文件，用于高效表示某一时刻的虚拟目录内容。它通过一个简单的数组实现，将一组名称、日期、权限和内容（即 blob 对象） 关联在一起。
缓存始终按文件名排序，且在任意时刻文件名都是唯一的，但该缓存没有长期意义，并且可以随时进行部分更新。

特别地，“当前目录缓存”不必与当前目录的实际内容保持一致，但它有两个非常重要的属性：

（a）它可以重新生成其缓存的完整状态（不仅是目录结构：通过 blob 对象，它还可以重新生成数据本身）。

    作为一个特殊情况，当前目录缓存可以清晰且明确地单向映射到一个 tree 对象，而且只需依赖当前目录缓存即可高效生成，无需查看其他数据。
    因此，在任意时刻的目录缓存都唯一指定了一个且仅有一个 “tree” 对象（但它包含额外的数据，以便轻松将该 tree 对象与目录中发生的操作对应起来）。

 以及

（b）它提供了高效的方法来查找该缓存状态（即“待实例化的 tree 对象”）与当前状态之间的不一致。

这是目录缓存仅有的两项功能。它是一个缓存，正常的操作是从一个已知的 tree 对象完全重新生成，或者与正在开发的 live tree 进行更新/比较。
如果你把目录缓存彻底删了，只要保留了它所描述的 tree 的名称，就不会丢失任何信息。

（但是目录缓存中也可以包含真实信息：特别是，它们可以表示尚未实例化的中间 tree。
因此，它们在缓存之外也有意义和用途——从某种意义上，你可以把当前目录缓存看作是向 tree 提交推进的“进行中的工作”。）