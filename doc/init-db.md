## init-db.c 的作用与设计

`init-db.c` 是早期 Git 的仓库初始化程序，职责非常单一但关键：在当前目录下创建对象数据库所需的最小目录结构。  
在这版代码里，仓库元目录还叫 `.dircache`，对象库默认是 `.dircache/objects`。这个程序完成初始化后，后续命令才能把
`blob/tree/commit` 等对象真正写入磁盘。

从能力上看，`init-db` 可以理解为后来的 `git init` 的早期核心子能力之一。

## 它具体做了什么

程序执行路径很短，核心流程如下：

1. 创建 `.dircache` 目录。
2. 尝试读取环境变量 `SHA1_FILE_DIRECTORY` 作为对象库存放路径。
3. 如果环境变量路径不可用，则回退到默认路径 `.dircache/objects`。
4. 创建对象库目录。
5. 在对象库下创建 `00` 到 `ff` 共 256 个子目录。

这 256 个子目录对应 SHA-1 十六进制前两位分桶。后续对象文件会按哈希前缀落入对应目录，例如哈希以 `ab` 开头就写入
`objects/ab/`。这样避免把海量对象放进同一个目录，显著减轻目录项查找和管理压力。

## 代码中的 Linux/Unix 设计巧思

虽然文件很短，但能看到非常典型的 Linux 工程风格，特点是“简单、直接、可组合”。

1. 统一系统调用差异  
   通过 `MKDIR` 宏屏蔽 Unix 与 Windows 的 `mkdir` 差异。调用点只写一套逻辑，平台差异留给预处理阶段。

2. 最小必要权限  
   Unix 下使用 `0700` 创建目录，默认只允许所有者访问。这是安全默认值：在不增加复杂度的前提下先保证对象库私有性。

3. 明确的失败即退出策略  
   目录创建失败时直接 `perror + exit(1)`，不做复杂恢复。这种策略在底层工具里很常见：尽早失败，避免半初始化状态。

4. `errno == EEXIST` 的幂等处理  
   创建目录时把“目录已存在”视为可接受结果。这样重复执行初始化命令不会无谓失败，兼顾鲁棒性和可运维性。

5. 环境变量覆盖默认配置  
   先尝试 `SHA1_FILE_DIRECTORY`，否则回落到默认目录。这体现了 Unix 传统：优先支持通过环境进行外部注入配置。

6. 目录分桶而非复杂索引  
   `00..ff` 两位前缀分桶是非常低成本但高收益的设计。无需额外元数据结构，就能得到稳定、可扩展的对象存储布局。

## 在 Git 初始提交中的地位

`init-db.c` 不是“花哨功能”，而是对象模型能落地的前置条件。  
如果没有它，`write_sha1_file` 一类对象写入逻辑就没有可用目录结构，Git 的内容寻址存储无法启动，提交历史也无从建立。

换句话说，这个文件虽然代码量小，但它完成的是“把设计变成可运行系统”的第一步：先把对象数据库骨架搭起来，再让其余命令在这个骨架上工作。
