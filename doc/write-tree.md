## write-tree.c 的作用与设计

`write-tree.c` 的职责很纯粹：把索引中的当前快照固化成一个 tree 对象，并写入对象库。  
它是早期 Git 从“暂存状态”走向“可提交对象”的桥梁。

在初始 Git 链路里，`update-cache` 负责把文件放进索引，`write-tree` 负责把索引变成树，`commit-tree` 再把树挂成提交。

## 它具体做了什么

流程可以概括为：

1. 读取索引（`read_cache`）。  
2. 遍历索引项，确认每个条目引用的 blob 对象确实存在。  
3. 组装 tree 数据体（`mode + path + NUL + 20-byte sha1`）。  
4. 在数据体前加对象头（`tree <size>\0`）。  
5. 压缩后写入对象库，并输出 tree 的 SHA-1。

这一步的结果是一个稳定、可复用、可引用的目录快照对象。

## 代码中的 Linux/Unix 设计巧思

`write-tree.c` 很短，但能看到几处非常“Linus 风格”的取舍。

1. 数据格式直接贴合对象协议  
   代码在内存里直接构造 Git 对象原始字节布局，而不是引入额外抽象层。  
   优点是路径短、转换少、性能和可控性都好。

2. 先验证引用完整性，再写新对象  
   在生成 tree 前，会检查索引项引用的 blob 是否可读。  
   这是一种很务实的一致性策略：宁可早失败，也不产出坏对象。

3. “预留头部 + 回填长度”的内存布局技巧  
   先写数据体，再反向补 `tree <size>\0` 头部。  
   这种技巧避免多次拼接与拷贝，代码量小但效率很高。

4. 动态扩容策略简单有效  
   初始按经验值分配，空间不足时按 `alloc_nr` 扩容。  
   这是典型 C 时代工程实践：不过度设计，先保证低成本和可维护性。

5. 复用通用对象写入通道  
   最终交给 `write_sha1_file` 完成压缩、哈希、落盘。  
   这使 tree/blob/commit 的写入路径在底层保持一致，减少重复逻辑。

## 设计层面的意义

`write-tree` 体现了 Git 最核心的思想之一：  
提交不是“保存目录”，而是“保存对象图中的引用关系”。

索引是候选快照，tree 是正式快照对象。  
把索引转为 tree，等于把“临时状态”提升为“内容寻址、可长期引用”的稳定节点。

## 在 Git 初始提交中的地位

它在最小闭环中的位置是：

1. `init-db`：准备对象库存储结构  
2. `update-cache`：把工作区内容写为 blob，并更新索引  
3. `write-tree`：把索引转换为 tree 对象  
4. `commit-tree`：生成 commit 对象并关联 tree

`write-tree` 的价值在于，它把“可编辑世界”（工作区/索引）和“不可变历史世界”（对象图）连接起来。
